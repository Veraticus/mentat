# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

Mentat is a personal assistant bot that combines:
- **Claude Code** as the AI brain (via SDK/CLI)
- **Signal messenger** for user interaction (via signal-cli JSON-RPC)
- **MCP servers** for data access (calendar, memory, email)
- **Proactive scheduling** via cron jobs

The Go application acts as a thin orchestration layer, handling Signal I/O and scheduling tasks that Claude cannot do reactively.

## Development Commands

```bash
# Build
make build                    # Build the mentat binary
go build ./cmd/mentat        # Alternative build command

# Test
make test                    # Run all tests with coverage
go test -short ./...         # Run unit tests only (skip integration)
go test -v ./... -run Integration  # Run integration tests (local only)

# Lint
make lint                    # Run golangci-lint with project config
golangci-lint run           # Alternative lint command

# Database
sqlite3 /var/lib/mentat/mentat.db  # Access SQLite database
.tables                            # List all tables
.schema messages                   # Show table schema

# Format
gofmt -w .                  # Format all Go files

# Dependencies
go mod tidy                 # Clean up module dependencies
go mod download             # Download dependencies

# MCP Services (via podman)
podman ps                    # Check running MCP containers
podman logs mcp-google-calendar  # View MCP server logs
curl http://localhost:3000/health  # Health check MCP service
```

## Architecture

The codebase follows an interface-driven architecture for complete testability:

```
cmd/mentat/          # Main application entry point
internal/            # Private application code
  signal/           # Signal messenger integration (JSON-RPC)
    interfaces.go   # Messenger interface definition
  claude/           # Claude Code SDK integration
    interfaces.go   # LLM interface definition
  agent/            # Multi-agent validation system
    handler.go      # Core orchestration logic
    validator.go    # Validation strategies
    interfaces.go   # Core handler interfaces
  conversation/     # Session management
    interfaces.go   # SessionManager interface
  queue/            # Message queue system
    manager.go      # Queue orchestration
    worker.go       # Worker pool
    state.go        # State machine
    limiter.go      # Rate limiting
  scheduler/        # Cron job management
  testing/          # Test utilities and mocks
tests/              # Integration and scenario tests
```

### Core Components

1. **MessageQueue**: Conversation-aware queue with state machine
2. **WorkerPool**: Processes messages with rate limiting
3. **AgentHandler**: Orchestrates multi-agent validation flow
4. **LLM Interface**: Abstracts Claude interactions for testing
5. **Messenger Interface**: Abstracts Signal (extensible to other channels)
6. **SessionManager**: Maintains 5-minute conversation windows
7. **ValidationStrategy**: Pluggable validation approaches

### Key Design Principles

- **Interface-driven**: All external dependencies behind interfaces
- **Queue-based architecture**: Messages queue with per-conversation ordering
- **Multi-agent validation**: Claude validates Claude to prevent hallucinations
- **Conversation continuity**: 5-minute window for related messages
- **Natural responses**: All user messages generated by Claude
- **Rate limiting**: Prevents overload while maintaining fairness
- **Comprehensive testing**: Full test harness with scripted scenarios

## Testing Strategy

- **Unit tests**: For all business logic in `internal/`
- **Integration tests**: Test Signal and Claude integration (marked with `// +build integration`)
- **Mock external services**: Use interfaces for Signal and Claude clients
- **Table-driven tests**: For complex logic like message parsing

Run integration tests locally with:
```bash
go test -v ./... -run Integration
```

## Linting Rules

The project enforces strict linting via `.golangci.yml`:
- **No `interface{}`** - use `any` instead
- **No direct `exec.Command`** - wrap in safeexec helper
- **No `panic`** - return errors instead
- **All 31 linters** must pass including security (gosec)

## MCP Integration

MCP servers are configured in `mcp-config.json`:
- **memory**: Persistent conversation context
- **google-calendar**: Schedule management
- **gmail**: Email access for briefings

Each Claude query includes the MCP config path and a specific session ID.

## MCP Integration

MCP servers run as HTTP services via podman containers:
- **Google Calendar** (port 3000): Schedule management
- **Google Contacts** (port 3001): Contact information
- **Gmail** (port 3002): Email access
- **Todoist** (port 3003): Task management
- **Memory** (port 3004): Persistent context storage
- **Expensify** (port 3005): Expense reporting and receipt management

Credentials are stored in `~/.config/mentat/` and mounted into containers at runtime.

## Deployment

The project includes a complete NixOS flake for deployment:
- Build with: `nix build`
- Run development shell: `nix develop`
- Deploy as NixOS service via the provided module
- MCP servers managed as podman containers

## Current Status

The project has comprehensive architecture documentation but **no implementation yet**. The 3-week implementation plan in ARCHITECTURE.md outlines:
- Week 1: Core interfaces, queue system, and Signal integration
- Week 2: Multi-agent validation and MCP integration
- Week 3: Polish, deployment, and monitoring

## Key Documentation

- **ARCHITECTURE.md**: Complete system design with SQLite persistence
- **docs/signal-rpc-integration.md**: Detailed Signal-CLI JSON-RPC integration guide